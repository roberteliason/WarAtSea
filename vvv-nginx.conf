server {
    # Listen at port 80 for HTTP requests
    listen			80;

    # Listen at port 443 for secure HTTPS requests
    listen			443 ssl;

    # The domain name(s) that the site should answer
    # for. You can use a wildcard here, e.g.
    # *.example.com for a subdomain multisite.
    server_name     waratsea.dev;

    # The folder containing your site files.
    # The {vvv_path_to_folder} token gets replaced
    # with the folder containing this, e.g. if this
    # folder is /srv/www/foo/ and you have a root
    # value of `{vvv_path_to_folder}/htdocs` this
    # will be auto-magically transformed to
    # `/srv/www/foo/htdocs`.
    root			{vvv_path_to_folder}/web;

    location / {
        # try to serve file directly, fallback to app.php
        try_files $uri /app.php$is_args$args;
    }

    # DEV
    # This rule should only be placed on your development environment
    # In production, don't include this and don't deploy app_dev.php or config.php
    location ~ ^/(app_dev|config)\.php(/|$) {
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    # PROD
    location ~ ^/app\.php(/|$) {
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        # Prevents URIs that include the front controller. This will 404:
        # http://domain.tld/app.php/some-path
        # Remove the internal directive to allow URIs like this
        internal;
    }

    error_log /var/log/nginx/symfony2test_error.log;
    access_log /var/log/nginx/symfony2test_access.log;

}
